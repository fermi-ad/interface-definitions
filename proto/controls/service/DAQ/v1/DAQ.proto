// This protocol is used to read and set accelerator devices.

syntax = "proto3";

option java_multiple_files = false;
option java_package = "gov.fnal.controls.service.proto.grpc";
option java_outer_classname = "DAQProto";

package services.daq;

import "google/protobuf/timestamp.proto";

import "proto/controls/common/v1/device.proto";
import "proto/controls/common/v1/status.proto";

// The DAQ API.
//
// gRPC clients use these to gain access to accelerator devices.

service DAQ {

    // Requests device readings from DPM.
    //
    // The parameter contains an array of specifications. Each entry
    // uses DRF to indicate which device is to be read and at what
    // rate. DPM will return a stream of readings.
    //
    // NOTE: DPM will close the stream when no more data will be
    // received. For instance, if a request asks for multiple devices
    // to be read once, DPM will close the stream when every device
    // has returned one value.

    rpc Read(ReadingList) returns (stream ReadingReply) {}

    // In order to set devices, a client needs to provide a JWT along
    // with the `Set` request. The JWT is passed in the http headers
    // and will be used by DPM to determine whether the client is
    // authorized to set the device.

    rpc Set(SettingList) returns (SettingReply) {}

    // The parameter contains an array of device names.

    rpc Alarms(DeviceList) returns (AlarmsReply) {}
}

// Used as the parameter to the `Read()` request.
//
// Contains a list of DRF strings which DPM uses to determine which
// devices to read and at what sample rate.

message ReadingList {
    repeated string drf = 1;
}

// One reading of a device.

message Reading {
    // The UTC timestamp of when the data was sampled.

    google.protobuf.Timestamp timestamp = 1;

    // The value read from the device. Note this can be any of the
    // valid device types that our control system supports.

    common.device.Value data = 2;

    // An associated status code. Normally 0, but could be a positive
    // value indicating extra status information. Right now, this maps
    // to our current ACNET status codes. This field will be dropped
    // in favor of a control system agnostic status field.

    common.status.Status status = 3 [deprecated = true];
}

// A container for multiple device readings.
//
// Some requests may generate a lot of data. Rather than have a
// message serialized/deserialized for each data point, we allow DPM
// to group them in one message. The clients can loop through the
// results and process them one by one. For slower requests, this
// array will most likely only ever contain one data point.

message Readings {
    repeated Reading reading = 2;
}

// One element of the stream returned by `Read()`.

message ReadingReply {

    // Indicates to which entry in the request list this reply
    // corresponds.

    uint32 index = 1;

    // The reply can contain either a reading or a fatal ACNET status
    // code. If a status code is returned, there will never be another
    // reply for this index in the stream.

    oneof value {
        Readings readings = 2;
        common.status.Status status = 3;
    }
}

// A setting to be made.

message Setting {

    // The name of the device to be set.

    string device = 1;

    // The value to set.

    common.device.Value value = 2;
}

// Holds an array of settings.

message SettingList {
    repeated Setting setting = 1;
}

// The reply message of `Set()`. Contains an arrays of status
// values. These correspond to the entries in the setting request.

message SettingReply {
    repeated common.status.Status status = 2;
}

message DeviceList {
    repeated string device = 1;
}

message AlarmsReply {

    // Indicates to which entry in the request list this reply
    // corresponds.

    uint32 index = 1;

    // The reply can contain either a reading or a fatal ACNET status
    // code. If a status code is returned, there will never be another
    // reply for this index in the stream.

    oneof value {
        AlarmList alarms = 2;
        common.status.Status status = 3;
    }
}

message AlarmList {
    repeated Alarm alarm = 1;
}

//  Represents the occurence of one of several types of alarms
//      1) ACNET Analog Alarm
//      2) ACNET Digital Alarm
//      3) EPICS PV Alarm

message Alarm {
    enum Status {
        STAT_NONE = 0;      //  No alarm
        STAT_HIHI = 1;      //  High-high limit exceeded
        STAT_HIGH = 2;      //  High limit exceeded
        STAT_LOW  = 3;      //  Lower than low limit
        STAT_LOLO = 4;      //  Lower than low-low limit
        STAT_BOOL = 5;      //  Boolean alarm
    }
    enum Severity {
        SEV_NONE  = 0;      //  No alarm
        SEV_EVENT = 1;      //  An informational alarm
        SEV_MINOR = 2;      //  An alarm of minor importance
        SEV_MAJOR = 3;      //  An alarm of major importance
    }
    Status status = 1;
    Severity severity = 2;
    bool enabled = 3;           //  true: this alarm should be indicated and annunciated if criteria are met
    bool bypassed = 4;          //  true: this alarm should be indicated but not annunciated if criteria are met
    bool acknowledged = 5;      //  true: this alarm has been acknowledged by a client
    uint32 snoozeMillis = 6;    //  set by client and decremented by front-end
    string text = 7;
    string url = 8;
    string name = 9;            //  name for this alarm (unique on device)
    string device = 10;         //  device name (aka PV name)
    //  priority        //  arbitrary integer for comparing ACNET alarms
    //  sound
    //  speech
    //  handler code    //  ACNET concept ?
}
