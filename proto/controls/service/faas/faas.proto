syntax = "proto3";

package services.faas;

// high-level RPC to manage Fission resources

service FissionManager {
  // Function operation using inline code (python/handler) and environment name.
  rpc CreateFunction(CreateFunctionRequest) returns (GenericResponse);
  rpc UpdateFunction(UpdateFunctionRequest) returns (GenericResponse);
  rpc DeleteFunction(DeleteFunctionRequest) returns (GenericResponse);

  // By default all functions will have HTTP trigger 
  // HTTP trigger operation to expose function via Fission router
  //rpc CreateHTTPTrigger(CreateHTTPTriggerRequest) returns (GenericResponse);
  //rpc UpdateHTTPTrigger(UpdateHTTPTriggerRequest) returns (GenericResponse);
  //rpc DeleteHTTPTrigger(DeleteHTTPTriggerRequest) returns (GenericResponse);

  // Create timer trigger (cron-like spec)
  rpc CreateTimerTrigger(CreateTimerTriggerRequest) returns (GenericResponse);
  rpc UpdateTimerTrigger(UpdateTimerTriggerRequest) returns (GenericResponse);
  rpc DeleteTimerTrigger(DeleteTimerTriggerRequest) returns (GenericResponse);

  // Create message queue trigger for kafka
  rpc CreateMessageQueueTrigger(CreateMQTriggerRequest) returns (GenericResponse);
  rpc UpdateMessageQueueTrigger(UpdateMQTriggerRequest) returns (GenericResponse);
  rpc DeleteMessageQueueTrigger(DeleteMQTriggerRequest) returns (GenericResponse);
}

message GenericResponse {
  bool success = 1;
  string message = 2;
  int32 exit_code = 3;
  string details = 4;
}


// CreateFunction (inline code)
message CreateFunctionRequest {
  string name = 1;
  string environment = 2;
  string source_type = 3; 	// "python"|"binary"|"archive" etc.
  string entrypoint = 4;  	// e.g., "handler" or executable
  string code = 5;        	// inline code or base64 if binary (we use plain text for small examples)
  string url_path = 6;    	// http path (for http trigger)
  string method = 7;   		// GET, POST etc.
}

// UpdateFunction (inline code)
message UpdateFunctionRequest {
  string name = 1;
  string environment = 2;
  string source_type = 3;       // "python"|"binary"|"archive" etc.
  string entrypoint = 4;        // e.g., "handler" or executable
  string code = 5;              // inline code or base64 if binary (we use plain text for small examples)
  string url_path = 6;          // http path (for http trigger)
  string method = 7;            // GET, POST etc.
}

// DeleteFunction (inline code)
message DeleteFunctionRequest {
  string name = 1;
  string url_path = 2;    // optional http path (for http trigger)
}

// CreateHTTPTrigger
//message CreateHTTPTriggerRequest {
//  string name = 1;
//  string function_name = 2;
//  string route = 3;    // e.g. "/myfunc"
//  string method = 4;   // GET, POST etc.
//}

// DeleteHTTPTrigger
//message DeleteHTTPTriggerRequest {
//  string name = 1;
//}

// CreateTimerTrigger
message CreateTimerTriggerRequest {
  string name = 1;
  string function_name = 2;
  string cron = 3;     // cron spec, e.g. "*/5 * * * *"
}

// UpdateTimerTrigger
message UpdateTimerTriggerRequest {
  string name = 1;
  string function_name = 2;
  string cron = 3;
}

// DeleteTimerTrigger
message DeleteTimerTriggerRequest {
  string name = 1;
}

// Create Message Queue (Kafka) Trigger
message CreateMQTriggerRequest {
  string name = 1;
  string function_name = 2;
  string request_topic = 3;
  string response_topic = 4;
  string error_topic = 5;
  string table_name = 6;	// optional if function want to push to longterm storage
  string column_name = 7; 	// optional 
  //string broker = 4;  // e.g. "kafka:9092"
  //int32 partition = 5;
}

// Create Message Queue (Kafka) Trigger
message UpdateMQTriggerRequest {
  string name = 1;
  string function_name = 2;
  string request_topic = 3;
  string response_topic = 4;
  string error_topic = 5;
  string table_name = 6;        // optional if function want to push to longterm storage
  string column_name = 7;       // optional
  //string broker = 4;  // e.g. "kafka:9092"
  //int32 partition = 5;
}

// Delete Message Queue (Kafka) Trigger
message DeleteMQTriggerRequest {
  string name = 1;
}

