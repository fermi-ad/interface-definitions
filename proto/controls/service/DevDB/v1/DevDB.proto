syntax = "proto3";

package services.devdb;

service DevDB {
    // Clients can ask for device information (obtained from the
    // device database.) The function is passed an array of device
    // names. The function returns an array of results. The order of
    // the results is the same as the request.

    rpc getDeviceInfo(DeviceList) returns (DeviceInfoReply) {}
    rpc getAllAlarmInfo(DeviceList) returns (AlarmInfoReply) {}

    // This function allows clients to monitor device info changes.
    // The client passes an array of device names. The function
    // returns a stream which will report all changes to the device's
    // information until the stream is canceled. The client will
    // receive a complete set of device information before monitoring
    // changes so there's no need to do an initial call to
    // `getDeviceInfo()`.

    // rpc monitorDeviceInfo(DeviceList) returns (stream InfoEntry) {}
}


// Holds an array of device names (strings).
message DeviceList {
    repeated string device = 1;
}

message Property {
    optional string primary_units = 1;
    optional string common_units = 2;
    double min_val = 3;
    double max_val = 4;
    uint32 p_index = 5;
    uint32 c_index = 6;
    repeated double coeff = 7;
    bool is_step_motor = 8;
    bool is_destructive_read = 9;
    bool is_fe_scaling = 10;
    bool is_contr_setting = 11;
    bool is_knobbable = 12;
}

// Defines the information associated with one bit of the digital
// status.

message DigitalStatusItem {
    uint32 mask_val = 1;
    uint32 match_val = 2;
    bool invert = 3;
    string short_name = 4;
    string long_name = 5;
    string true_str = 6;
    uint32 true_color = 7;
    string true_char = 8;
    string false_str = 9;
    uint32 false_color = 10;
    string false_char = 11;
}

message DigitalExtStatusItem {
    uint32 bit_no = 1;
    uint32 color0 = 2;
    string name0 = 3;
    uint32 color1 = 4;
    string name1 = 5;
    string description = 6;
}

// Holds all the Digital Status information for the device.

message DigitalStatus {
    repeated DigitalStatusItem bits = 1;
    repeated DigitalExtStatusItem ext_bits = 2;
}

// A single Digital Control item which defines the information
// associated with one command.

message DigitalControlItem {
    uint32 value = 1;
    string short_name = 2;
    string long_name = 3;
}

// Holds all the Digital Control commands for the device.

message DigitalControl {
    repeated DigitalControlItem cmds = 1;
}

// Holds information about a device.

message DeviceInfo {
    uint32 device_index = 1;
    string description = 2;
    optional Property reading = 3;
    optional Property setting = 4;
    optional DigitalControl control = 5;
    optional DigitalStatus status = 6;
}

// One entry in `DeviceInfoReply`s array.

message InfoEntry {
    string name = 1;
    oneof result {
	DeviceInfo device = 2;
	string errMsg = 3;
    }
}

// Holds an array

message DeviceInfoReply {
    repeated InfoEntry set = 1;
}

message AlarmBlock {
    int32 di = 1;                          // Device Identifier (4 byte integer)
    uint32 pi = 2;                         // Property type (1 byte integer)
    bytes status = 3;                      // Status word (2 byte binary, hexified)
    int32 min_or_nom = 4;                  // Min/Nominal value (4 byte integer)
    int32 max_or_tol = 5;                  // Max/Tolerance/Mask (4 byte integer)
    uint32 tries_needed = 6;               // Number of out-of-tolerance samples (1 byte integer)
    uint32 tries_now = 7;                  // Current tries from front end (1 byte integer)
    bytes clock_event_no = 8;              // Clock event number (1 byte binary)
    uint32 subfunction_code = 9;           // Subfunction code (1 byte integer)
    bytes specific_data = 10;              // Front-end specific data (6 byte binary, hexified)
    int32 segment = 11;                    // Alarm block number (4 byte integer)
}

message DeviceDigitalAlarm{
    int32 di = 1;
    int32 condition = 2;
    int32 mask = 3;
    int32 alarm_text_id = 4;
}

message DeviceAnalogAlarm {
    int32 di = 1;
    int32 alarm_text_id = 2;        
}

message DeviceAlarmText {
    uint32 alarm_text_id = 1;   // (1-99999)
    uint32 length = 2;
    uint32 priority = 3;            // (0-10, 10 represents the highest priority)
    uint32 hand_code = 4;
    uint32 sound_id = 5;
    uint32 speech_id = 6;
    int32 spare = 7;
    bytes text = 8;             // 80 byte alphanumeric (not null nor blanks)
    bytes url = 9;              // 128 byte alphanumeric (may be blank if no URL)
}

message AlarmInfo {
    AlarmBlock alarm_block = 1;
    optional DeviceAnalogAlarm device_analog_alarm = 2;
    optional DeviceDigitalAlarm device_digital_alarm = 3;
}

message AlarmInfoReply {
    repeated AlarmInfo alarm_info = 1;
}
